<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
      }
      .main {
        position: relative;
      }
      .item {
        position: absolute;
        background: no-repeat center center #ffffff;
        border: 1px solid #ddd;
        background-size: 100%;
        /* color: transparent; */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 0;
        transition: left 0.3s, top 0.3s, transform 0.3s;
      }
      .item:after {
        content: "";
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        transition: background-color 0.2s;
      }
      .disabled:after {
        background-color: rgba(0, 0, 0, 0.7);
        /* border: 1px solid rgb(0, 0, 0); */
      }
      .move-list {
        border: 1px solid #ddd;
        background-color: #ddd;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <div class="main"></div>
    <div class="move-list"></div>
  </body>
  <script>
    // 基础数据
    const simpleData = [
      { name: "虎", color: "#ff1100" },
      { name: "兔", color: "#ff8800" },
      { name: "牛", color: "green" },
      { name: "羊", color: "blue" },
      { name: "蛇", color: "#779922" },
      { name: "鼠", color: "#335577" },
    ];
    const size = 30;
    const rows = 3;
    const cols = 3;
    //4个消除一次
    const oneGoupCount = 10;
    // 每个卡片有x组
    const group = 2;
    //6层
    const layerCount = 5;
    const cellHtml = [];

    const renderData = Array.from(new Array(oneGoupCount * group))
      .map((v) => {
        return simpleData.map((v) => ({ ...v }));
      })
      .flat()
      .sort((v) => Math.random() - 0.5);
    //绘制图层的逻辑
    for (let ly = layerCount - 1; ly >= 0; ly--) {
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          //5 4 3 2 1 0

          let pyStep = ly % 2 === 0 ? size / 2 : 0;
          let item = Math.random() < 0.7 && renderData.pop();
          item &&
            cellHtml.push(`
          <div class="item" id="m${ly}-${i}-${j}"
          onclick="move(this)"
          style="width:${size}px;height:${size}px;left:${size * j + pyStep}px;
          top:${size * i + pyStep}px;background-color:${item.color};">${
              item.name || ""
            }</div>
          `);
        }
      }
    }
    //===找到元素
    const main = document.querySelector(".main");

    main.innerHTML = cellHtml.reverse().join("");
    main.style.height = `${size * rows + size * 2}px`;
    main.style.width = `${size * rows}px`;

    //第二步：计算出背遮住的底牌，并且标注暗色
    const moveList = document.querySelector(".move-list");
    moveList.style.height = `${size}px`;
    moveList.style.width = `${size * 6}px`;
    const checkDisabled = () => {
      document.querySelectorAll(".item").forEach((item, index) => {
        let arr = item.id.substring(1).split("-");
        arr = arr.map((item) => Number(item));
        //pyA是当前元素的层级？是否偏移
        let pyA = arr[0] % 2 == 0;
        for (let i = arr[0] + 1; i < layerCount; i++) {
          //pyB是要对比的层级？是否偏移
          let pyB = i % 2 == 0;

          if (pyA == pyB) {
            let el = main.querySelector(`#m${i}-${arr[1]}-${arr[2]}`);
            if (el) {
              item.classList.add("disabled");
              break;
            }
            //偏了，对比没偏的
          } else if (!pyA && pyB) {
            const result = [
              `${i}-${arr[1]}-${arr[2]}`,
              `${i}-${arr[1]}-${arr[2] - 1}`,
              `${i}-${arr[1] - 1}-${arr[2]}`,
              `${i}-${arr[1] - 1}-${arr[2] - 1}`,
            ].every((k) => {
              return !main.querySelector("#m" + k);
            });
            if (!result) {
              item.classList.add("disabled");
              break;
            } else {
              item.classList.remove("disabled");
            }
            //当前在0 对比1,偏了，对比没偏的
          } else if (pyA && !pyB) {
            const result = [
              `${i}-${arr[1]}-${arr[2]}`,
              `${i}-${arr[1]}-${arr[2] + 1}`,
              `${i}-${arr[1] + 1}-${arr[2]}`,
              `${i}-${arr[1] + 1}-${arr[2] + 1}`,
            ].every((k) => {
              return !main.querySelector("#m" + k);
            });
            if (!result) {
              item.classList.add("disabled");
              break;
            } else {
              item.classList.remove("disabled");
            }
          }
        }
      });
    };
    checkDisabled();
    //==
    //第三步，对比卡片进行消除计算
    let canMove = true;
    const move = (me) => {
      let left = moveList.offsetLeft;
      let top = moveList.offsetTop;
      console.log(me, "--");
      //如果不可以移动，或者禁用，则返回
      if (!canMove || me.className.indexOf("disabled") >= 0) {
        return;
      }
      canMove = false;
      //如果容器里面已经有值了，位置就要变化
      if (moveList.children.length > 0) {
        let el = moveList.children[moveList.children.length - 1];
        left = el.offsetLeft + size;
        top = el.offsetTop;
      }
      me.style.top = `${top}px`;
      me.style.left = `${left}px`;
      me.transitionNamesCount = 0;
      //执行时机
      me.ontransitionend = (e) => {
        me.transitionNamesCount++;
        if (me.transitionNamesCount === 2) {
          moveEnd(me);
          canMove = true;
        }
      };
    };

    // 动画结束的相关计算
    const moveEnd = (me) => {
      me.ontransitionend = null;
      me.setAttribute("onclick", "");
      moveList.appendChild(me);

      const findResult = [...moveList.children].filter(
        (v) => v.innerHTML === me.innerHTML,
      );
      if (findResult.length === 3) {
        findResult.forEach((v) => {
          v.ontransitionend = (e) => {
            moveList.removeChild(v);
            [...moveList.children].forEach((v, i) => {
              v.style.left = `${i * size + moveList.offsetLeft}px`;
            });
          };
          setTimeout(() => (v.style.transform = "scale(0)"));
        });
      }
      //一秒后判断是否，满足条件
      setTimeout(() => {
        if (moveList.children.length === 6) {
          alert("池子已满，游戏结束");
          return location.reload();
        } else if (main.children.length === 0) {
          alert("恭喜通关");
          return location.reload();
        }
      }, 200);
      checkDisabled();
    };

    checkDisabled();
  </script>
</html>
