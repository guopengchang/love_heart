<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>表白爱心</title>
    <style>
      body {
        margin: 0;
        background-color: #000;
        color: rgb(215, 61, 133);
      }
      canvas {
        animation: run infinite 10s linear;
      }
      .text {
        position: absolute;
        z-index: 1;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 50px;
        opacity: 0.5;
        white-space: pre;
      }
      @keyframes run {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1);
        }
        100% {
          transform: scale(0);
        }
      }
    </style>
  </head>

  <body>
    <div class="text">I LOVE YOU</div>
    <canvas id="myCanvas"></canvas>
    <script>
      function heart() {
        const cvs = document.getElementById("myCanvas");
        const { clientWidth: width, clientHeight: height } =
          document.documentElement;
        const ctx = cvs.getContext("2d");
        cvs.width = width;
        cvs.height = height;
        let radian = 0;
        //π/180求弧度
        let radian_add = Math.PI / 180;
        ctx.translate(width / 2, height / 2);
        //意味着阴影的模糊级别为 10 个像素。
        ctx.shadowBlur = 10;
        // ctx.lineJoin 是用于设置绘制路径时两条线交汇处的形状的属性之一。通过将其设置为 "round"，可以使交汇处呈现圆角形状，这样会使路径看起来更加平滑。这在绘制具有拐角的形状时特别有用，可以使得连接处更加自然。
        ctx.lineJoin = "round";
        ctx.shadowColor = "rgb(215, 61, 133)";
        ctx.strokeStyle = "rgb(215, 61, 133)";
        const points = [];
        //π * 2 可以简单地表示为直径的长度，其中直径是圆的宽度，π 是圆周率，约等于3.14159。因此，π * 2 表示的是圆的直径的长度。

        while (radian <= Math.PI * 2) {
          radian += radian_add;
          console.log(radian_add, "--", radian);

          const x = getX(radian);
          const y = getY(radian);
          ctx.lineTo(x, y);
          points.push({
            x,
            y,
            list: new Array(10).fill("").map((v) => {
              const fw = 100;
              const fx = x + Math.random() * fw - fw / 2;
              const fy = y + Math.random() * fw - fw / 2;
              return {
                x: x,
                y: y,
                endX: fx,
                endY: fy,
                stepX: x > fx ? -1 : 1,
                stepY: y > fy ? -1 : 1,
                parentX: x,
                parentY: y,
              };
            }),
          });
        }
        ctx.stroke();
        const render = () => {
          ctx.beginPath();
          //在 JavaScript 中，ctx.clearRect(x, y, width, height) 方法用于在给定的矩形区域内清除指定区域的像素，以使其变为透明。参数 x 和 y 是矩形区域左上角的坐标，而 width 和 height 分别是矩形区域的宽度和高度。

          //在这个特定的例子中，-width / 2 和 -height / 2 可能是为了将清除区域定位在画布的中心位置。
          //width 和 height 则确定了清除区域的宽度和高度，从而清除了一个矩形区域。这样的操作通常用于在绘制新内容之前清除之前的绘制内容，以确保画布上的内容保持更新。
          ctx.clearRect(-width / 2, -height / 2, width, height);
          ctx.lineWidth = 5;
          points.forEach((v) => {
            ctx.lineTo(v.x, v.y);
          });
          ctx.stroke();
          ctx.beginPath();
          ctx.lineWidth = 2;

          points.forEach((v) => {
            v.list.forEach((k) => {
              ctx.moveTo(k.x, k.y);
              ctx.lineTo(k.x + ctx.lineWidth, k.y + ctx.lineWidth);
              k.x += k.stepX;
              k.y += k.stepY;
              if (k.stepX > 0) {
                if (k.x > k.endX) {
                  k.x = k.endX;
                }
              } else {
                if (k.x < k.endX) {
                  k.x = k.endX;
                }
              }
              if (k.stepY > 0) {
                if (k.y > k.endY) {
                  k.y = k.endY;
                }
              } else {
                if (k.y < k.endY) {
                  k.y = k.endY;
                }
              }
              if (k.x === k.endX && k.y === k.endY) {
                k.x = k.parentX;
                k.y = k.parentY;
              }
            });
          });
          ctx.stroke();
          requestAnimationFrame(render);
        };
        render();
      }
      function getX(t) {
        return 15 * (12 * Math.sin(t) - 4 * Math.sin(3 * t));
      }
      function getY(t, bl = 1) {
        return (
          -15 *
          (13 * Math.cos(t) -
            5 * Math.cos(2 * t) -
            2 * Math.cos(3 * t) -
            Math.cos(4 * t))
        );
      }
      heart();
    </script>
  </body>
</html>
